<!DOCTYPE html>
<html lang="en">
<head>
	
	<!-- Custom Header Code For naiman.diet -->
			<meta name="keywords" content="satiety per calorie, satiety, SPC, ted naiman">
			<meta name="description" content="Satiety Per Calorie:  Eating, solved.  Book by Ted Naiman.">
			
	
			
			<link rel="canonical" href="https://www.naiman.diet" />
			
			<!-- Open Graph / Facebook -->
			<meta property="og:type" content="website">
			<meta property="og:url" content="https://naiman.diet">
			<meta property="og:title" content="Satiety Per Calorie">
			<meta property="og:description" content="Satiety Per Calorie:  Eating, solved.  Book by Ted Naiman.">
			<meta property="og:image" content="https://naiman.diet/logo.jpg">
			<meta property="og:site_name" content="Satiety Per Calorie">
			<meta property="og:image:width" content="1200">
			<meta property="og:image:height" content="630">
			<meta property="og:locale" content="en_US"> <!-- adjust this as per your primary audience -->
			
			<!-- Twitter -->
			<meta property="twitter:card" content="summary_large_image">
			<meta property="twitter:url" content="https://naiman.diet">
			<meta property="twitter:title" content="Satiety Per Calorie">
			<meta property="twitter:description" content="Satiety Per Calorie:  Eating, solved.  Book by Ted Naiman.">
			<meta property="twitter:image" content="https://naiman.diet/logo.jpg">
			
			<meta name="author" content="Ted Naiman">
			
			<title>Satiety Per Calorie</title>
			<meta charset="utf-8" />
			<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	
	
			
	<!-- code snippet for header -->
	
	<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
	<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
	<link rel="manifest" href="/site.webmanifest" />
	
	
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Trirectangular Tetrahedron Viewer</title>
	
	<!-- Import Inter Font -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

	<style>
		/* Darker, sleek environment */
		body { margin: 0; overflow: hidden; background-color: #222; color: #eee; font-family: 'Inter', sans-serif; }
		canvas { display: block; width: 100vw; height: 100vh; outline: none; }
		
		#loading {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			font-size: 1.5em;
			pointer-events: none;
			transition: opacity 0.5s;
			color: #fff;
		}
		/* Slider Controls */
		#controls {
			position: absolute;
			bottom: 30px;
			width: 100%;
			display: flex;
			justify-content: center;
			align-items: center;
			pointer-events: auto; 
			z-index: 10;
		}
		.slider-container {
			background: rgba(30, 30, 30, 0.8);
			padding: 15px 30px;
			border-radius: 30px;
			display: flex;
			flex-direction: column;
			align-items: center;
			backdrop-filter: blur(10px);
			box-shadow: 0 10px 30px rgba(0,0,0,0.5);
			border: 1px solid rgba(255,255,255,0.1);
			transition: all 0.3s ease;
		}
		
		/* Glow Effect for Snapped State */
		.slider-container.snapped {
			box-shadow: 0 0 25px rgba(255, 152, 0, 0.4), 0 10px 30px rgba(0,0,0,0.5);
			border-color: rgba(255, 152, 0, 0.6);
		}
		
		/* Labels Row */
		.labels-row {
			display: flex;
			justify-content: space-between;
			width: 100%;
			margin-top: 8px; /* Changed from margin-bottom to margin-top */
			font-size: 0.8rem;
			color: #ccc;
			font-weight: 400; /* Changed from bold */
			text-transform: uppercase;
			letter-spacing: 0.5px;
		}
		.label-left { text-align: left; }
		.label-right { text-align: right; }
		
		/* Range Input & Ticks Styling */
		.range-holder {
			position: relative;
			width: 100%;
			height: 40px; /* Increased height for ticks */
			display: flex;
			align-items: center;
			justify-content: center;
		}
		
		/* --- CUSTOM SLIDER CSS FOR PERFECT ALIGNMENT --- */
		input[type=range] {
			-webkit-appearance: none; /* Remove default styling */
			width: 100%;
			background: transparent;
			margin: 0;
			cursor: pointer;
			position: relative;
			z-index: 2;
		}
		
		input[type=range]:focus {
			outline: none;
		}

		/* Webkit Thumb (Chrome/Safari/Edge) */
		input[type=range]::-webkit-slider-thumb {
			-webkit-appearance: none;
			height: 20px; /* FIXED WIDTH */
			width: 20px;  /* FIXED WIDTH */
			border-radius: 50%;
			background: #FF9800;
			cursor: pointer;
			margin-top: -8px; /* Offset to center on 4px track */
			box-shadow: 0 0 5px rgba(0,0,0,0.5);
			border: 2px solid #fff;
		}

		/* Firefox Thumb */
		input[type=range]::-moz-range-thumb {
			height: 20px; /* FIXED WIDTH */
			width: 20px;  /* FIXED WIDTH */
			border-radius: 50%;
			background: #FF9800;
			cursor: pointer;
			border: 2px solid #fff;
			box-shadow: 0 0 5px rgba(0,0,0,0.5);
		}

		/* Track Styling */
		input[type=range]::-webkit-slider-runnable-track {
			width: 100%;
			height: 4px;
			background: rgba(255, 255, 255, 0.2);
			border-radius: 2px;
			cursor: pointer;
		}
		
		input[type=range]::-moz-range-track {
			width: 100%;
			height: 4px;
			background: rgba(255, 255, 255, 0.2);
			border-radius: 2px;
			cursor: pointer;
		}
		
		.ticks-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: space-between;
			align-items: center;
			pointer-events: none;
			/* PADDING CALCULATION FOR PERFECT ALIGNMENT: */
			/* Thumb Width (20px) / 2  MINUS  Tick Width (2px) / 2 */
			/* 10px - 1px = 9px */
			padding: 0 9px; 
			box-sizing: border-box;
			z-index: 1;
		}
		
		.tick {
			width: 2px;
			height: 8px;
			background-color: #000;
			border: 1px solid #444;
			transform: translateY(16px); /* Move below the thumb */
			transition: all 0.2s ease;
			border-radius: 2px;
			/* Ensure tick doesn't shrink in flex */
			flex-shrink: 0; 
		}
		
		.tick.active {
			background-color: #FF9800;
			border-color: #FF9800;
			box-shadow: 0 0 8px #FF9800, 0 0 12px #FF9800;
			/* REMOVED width/height changes to prevent layout jitter */
			/* height: 10px; */
			/* width: 3px; */
			
			/* Use Scale to grow visually from center without affecting layout positions */
			transform: translateY(16px) scale(1.5, 1.4);
		}

		/* Checkbox Styling */
		.header-row {
			display: flex;
			align-items: center;
			gap: 10px;
			cursor: pointer;
			margin-top: 15px; /* Changed from margin-bottom to margin-top to separate from slider */
		}
		input[type=checkbox] {
			accent-color: #FF9800;
			width: 18px;
			height: 18px;
			cursor: pointer;
		}
		label {
			font-weight: 400; /* Changed from bold */
			color: #FF9800;
			font-size: 0.9rem;
			letter-spacing: 1px;
			text-transform: uppercase;
			cursor: pointer;
		}
	</style>
</head>
<body>
	
	<div id="loading">Loading Assets...</div>

	<!-- Slider Control -->
	<div id="controls">
		<div class="slider-container">
			
			<div id="sliderWrapper" style="display: none; width: 300px;">
				<!-- 1. Text Placeholder Space -->
				<div id="detentText" style="width: 100%; text-align: center; margin-bottom: 15px; min-height: 1.2em; font-weight: 400; color: #fff; letter-spacing: 0.5px;"></div>

				<!-- 2. Slider Bar -->
				<div class="range-holder">
					<!-- Removed 'list' attribute to avoid native browser ticks interference -->
					<input type="range" id="planeSlider" min="0" max="100" value="0" step="0.01">
					<div class="ticks-container">
						<div class="tick" data-val="0"></div>
						<div class="tick" data-val="25"></div>
						<div class="tick" data-val="50"></div>
						<div class="tick" data-val="75"></div>
						<div class="tick" data-val="100"></div>
					</div>
				</div>

				<!-- 3. Directional Arrows -->
				<div class="labels-row">
					<div class="label-left">← Refinement</div>
					<div class="label-right">Satiety Per Calorie →</div>
				</div>
			</div>

			<!-- 4. Checkbox (Now at bottom) -->
			<div class="header-row">
				<input type="checkbox" id="refineCheck">
				<label for="refineCheck">REFINEMENT</label>
			</div>
			
		</div>
	</div>
	
	<!-- Three.js Library -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	<!-- OrbitControls -->
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
	<!-- FontLoader & TextGeometry -->
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

	<script>
		(function() {
			// --- 0. Cleanup Logic ---
			const existingCanvas = document.querySelector('canvas');
			if (existingCanvas) existingCanvas.remove();

			// --- 1. Scene Setup ---
			const scene = new THREE.Scene();
			const bgColor = 0x222222; 
			scene.background = new THREE.Color(bgColor);
			scene.fog = new THREE.Fog(bgColor, 15, 40);

			const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(6, 5, 8); 

			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.localClippingEnabled = true; 
			renderer.shadowMap.enabled = true; 
			renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(window.devicePixelRatio);
			
			renderer.domElement.setAttribute('tabindex', '0');
			renderer.domElement.style.outline = 'none'; 
			document.body.appendChild(renderer.domElement);
			renderer.domElement.focus();
			renderer.domElement.addEventListener('click', () => renderer.domElement.focus());
			renderer.domElement.addEventListener('mouseover', () => renderer.domElement.focus());

			// --- 2. Lighting ---
			const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
			hemiLight.position.set(0, 20, 0);
			scene.add(hemiLight);

			const spotLight = new THREE.SpotLight(0xffffff, 1.2);
			spotLight.position.set(0, 20, 0); 
			spotLight.angle = Math.PI / 6;
			spotLight.penumbra = 1.0; 
			spotLight.decay = 2;
			spotLight.distance = 100;
			spotLight.castShadow = true;
			spotLight.shadow.mapSize.width = 1024; 
			spotLight.shadow.mapSize.height = 1024;
			spotLight.shadow.bias = -0.0001;
			spotLight.shadow.radius = 5; 
			scene.add(spotLight);

			const rimLight = new THREE.DirectionalLight(0xffffff, 0.4);
			rimLight.position.set(-5, 5, -5);
			scene.add(rimLight);

			const floorGeom = new THREE.PlaneGeometry(1000, 1000);
			const floorMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 1, metalness: 0 });
			const floor = new THREE.Mesh(floorGeom, floorMat);
			floor.rotation.x = -Math.PI / 2;
			floor.position.y = -4.5; 
			floor.receiveShadow = true; 
			scene.add(floor);


			// --- 3. Asset Loading ---
			const fontLoader = new THREE.FontLoader();

			// --- 4. Geometry Construction ---
			const s = 2.5; 
			const offset = s / 4; 
			
			// Height Factor for Dynamic Flattening
			let heightFactor = 0.5;

			const vApex = new THREE.Vector3(0, 0, 0); 
			const vLegX = new THREE.Vector3(s, 0, 0); 
			const vLegY = new THREE.Vector3(0, s, 0); 
			const vLegZ = new THREE.Vector3(0, 0, s); 
			const vBaseCenter = new THREE.Vector3(s/3, s/3, s/3); 
			
			// New Midpoint for Mega Solids (Midpoint of Y-Z edge)
			const vMidYZ = new THREE.Vector3(0, s/2, s/2);

			const globalPlaneTip = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
			const globalPlaneBase = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0);

			function createTetrahedron(pApex, pLeg1, pLeg2, pBase, colorHex, clippingPlanesArray, opacity = 0.5) {
				const geom = new THREE.BufferGeometry();
				const vertices = [
					pApex.x, pApex.y, pApex.z,  pLeg1.x, pLeg1.y, pLeg1.z,  pLeg2.x, pLeg2.y, pLeg2.z,
					pApex.x, pApex.y, pApex.z,  pBase.x, pBase.y, pBase.z,  pLeg1.x, pLeg1.y, pLeg1.z,
					pLeg1.x, pLeg1.y, pLeg1.z,  pBase.x, pBase.y, pBase.z,  pLeg2.x, pLeg2.y, pLeg2.z,
					pLeg2.x, pLeg2.y, pLeg2.z,  pBase.x, pBase.y, pBase.z,  pApex.x, pApex.y, pApex.z
				];

				geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
				geom.computeVertexNormals();
				geom.translate(-offset, -offset, -offset);

				const material = new THREE.MeshStandardMaterial({ 
					color: colorHex, 
					roughness: 0.2, 
					metalness: 0.2, 
					flatShading: true,
					side: THREE.DoubleSide,
					clippingPlanes: clippingPlanesArray || [], 
					clipShadows: true,
					transparent: true,
					opacity: opacity, 
					depthWrite: false,
					depthTest: true
				});
				
				const mesh = new THREE.Mesh(geom, material);
				mesh.castShadow = true; 
				mesh.receiveShadow = true; 
				return mesh;
			}

			const pivotGroup = new THREE.Group();
			scene.add(pivotGroup);

			// Store mesh references
			const solids = {
				// Refinement Mode Solids (5-Part Logic)
				protein: null,
				fatTip: null,
				fatBase: null,
				carbsTip: null,
				carbsBase: null,
				
				// Classic Mode Solids (3-Part Logic, 1/3 each)
				classicProtein: null,
				classicFat: null,
				classicCarbs: null
			};

			// Single opacity value for all solids
			const solidOpacity = 0.5;

			// --- CONSTRUCT REFINEMENT PARTS (The "Mega" Solids for Slider Logic) ---
			
			// PROTEIN (Clipped by base plane)
			solids.protein = createTetrahedron(vApex, vLegY, vLegZ, vBaseCenter, 0x2962FF, [globalPlaneBase], solidOpacity); 
			
			// FAT (Tip extends to mid-YZ, Base is normal)
			solids.fatTip = createTetrahedron(vApex, vLegZ, vLegX, vMidYZ, 0xFFD600, [globalPlaneTip], solidOpacity); 
			solids.fatBase = createTetrahedron(vApex, vLegZ, vLegX, vBaseCenter, 0x40C4FF, [globalPlaneBase], solidOpacity); 

			// CARBS (Tip extends to mid-YZ, Base is normal)
			solids.carbsTip = createTetrahedron(vApex, vLegX, vLegY, vMidYZ, 0xFF1744, [globalPlaneTip], solidOpacity); 
			solids.carbsBase = createTetrahedron(vApex, vLegX, vLegY, vBaseCenter, 0x00E676, [globalPlaneBase], solidOpacity); 

			// --- CONSTRUCT CLASSIC PARTS (Standard 1/3 Split) ---
			// These use vBaseCenter as the meeting point for all three
			
			// Classic Protein (Blue)
			solids.classicProtein = createTetrahedron(vApex, vLegY, vLegZ, vBaseCenter, 0x2962FF, [], solidOpacity);
			
			// Classic Fat (Yellow)
			solids.classicFat = createTetrahedron(vApex, vLegZ, vLegX, vBaseCenter, 0xFFD600, [], solidOpacity);
			
			// Classic Carbs (Red)
			solids.classicCarbs = createTetrahedron(vApex, vLegX, vLegY, vBaseCenter, 0xFF1744, [], solidOpacity);


			// Add all to scene
			pivotGroup.add(solids.protein);
			pivotGroup.add(solids.fatTip);
			pivotGroup.add(solids.fatBase);
			pivotGroup.add(solids.carbsTip);
			pivotGroup.add(solids.carbsBase);
			
			pivotGroup.add(solids.classicProtein);
			pivotGroup.add(solids.classicFat);
			pivotGroup.add(solids.classicCarbs);

			// Orient Vertex Up
			const cornerDirection = new THREE.Vector3(-1, -1, -1).normalize();
			const upDirection = new THREE.Vector3(0, 1, 0);
			pivotGroup.quaternion.setFromUnitVectors(cornerDirection, upDirection);


			// --- 5. Bisection Plane Mesh ---
			const planeWidth = s * Math.sqrt(2);
			const planeHeight = s / Math.sqrt(3);
			const planeGeom = new THREE.PlaneGeometry(planeWidth, planeHeight); 
			planeGeom.translate(0, planeHeight / 2, 0); 

			const planeMat = new THREE.MeshBasicMaterial({ 
				color: 0xffffff, 
				side: THREE.DoubleSide, 
				transparent: true, 
				opacity: 0.15, 
				depthWrite: false, 
			});
			const bisectionPlane = new THREE.Mesh(planeGeom, planeMat);
			bisectionPlane.raycast = function() {}; 

			const borderGeom = new THREE.EdgesGeometry(planeGeom);
			const borderMat = new THREE.LineBasicMaterial({ color: 0xFF9800, transparent: true, opacity: 0.8 });
			const border = new THREE.LineSegments(borderGeom, borderMat);
			border.raycast = function() {}; 
			bisectionPlane.add(border);

			bisectionPlane.renderOrder = 999;
			pivotGroup.add(bisectionPlane);

			const localUp = new THREE.Vector3(-1, -1, -1).normalize(); 
			const localNormal = new THREE.Vector3(2, -1, -1).normalize();
			const localRight = new THREE.Vector3().crossVectors(localUp, localNormal).normalize();
			const correctedUp = new THREE.Vector3().crossVectors(localNormal, localRight).normalize();
			const planeMatrix = new THREE.Matrix4();
			planeMatrix.makeBasis(localRight, correctedUp, localNormal);
			bisectionPlane.rotation.setFromRotationMatrix(planeMatrix);

			
			// --- 6. 3D Text Legends & Update Logic ---
			
			const labelMeshes = {
				fat: null,
				water: null,
				carbs: null,
				fiber: null,
				protein: null,
				hedonic: null // Added Hedonic
			};

			const slider = document.getElementById('planeSlider');
			const checkbox = document.getElementById('refineCheck');
			const sliderWrapper = document.getElementById('sliderWrapper');
			const sliderContainer = document.querySelector('.slider-container');
			const ticks = document.querySelectorAll('.tick');
			const detentText = document.getElementById('detentText');
			let currentLocalPlanePosition = new THREE.Vector3();

			// EXPONENTIAL CURVE SETTINGS
			// We want Slider(0.5) to equal T(1/3).
			// Formula: y = x^k
			// 1/3 = 0.5^k  =>  ln(1/3) = k * ln(0.5)  => k = ln(1/3)/ln(0.5) ≈ 1.58496
			const EXPONENT = Math.log(1/3) / Math.log(0.5);
			
			// SNAP SETTINGS (Now snapping at visual 0, 25, 50, 75, 100)
			const DETENT_VALUES = [0, 25, 50, 75, 100]; 
			const SNAP_THRESHOLD = 2.0; 

			function updateLabels(t, isRefining) {
				if (!labelMeshes.fat) return;

				// If not refining (Unchecked), show only core macros
				if (!isRefining) {
					labelMeshes.fat.mesh.visible = true;
					labelMeshes.carbs.mesh.visible = true;
					labelMeshes.protein.mesh.visible = true;
					
					labelMeshes.water.mesh.visible = false;
					labelMeshes.fiber.mesh.visible = false;
					if (labelMeshes.hedonic) labelMeshes.hedonic.mesh.visible = false; // Hide Hedonic
					
					// Position labels at "Classic" locations
					updateLabelPos(labelMeshes.fat, vLegZ, vLegX, 0.5);
					updateLabelPos(labelMeshes.carbs, vLegY, vLegX, 0.5);
					
					return;
				}

				// Normal logic when refining
				const showBase = (t > 0.02);
				const showTip = (t < 0.98);

				// FAT Label (Tip)
				const fatT = (t + 1) / 2;
				updateLabelPos(labelMeshes.fat, vLegZ, vLegX, fatT);
				labelMeshes.fat.mesh.visible = showTip;

				// WATER Label (Base)
				const waterT = t / 2;
				updateLabelPos(labelMeshes.water, vLegZ, vLegX, waterT);
				labelMeshes.water.mesh.visible = showBase;

				// CARBS Label (Tip)
				const carbsT = (t + 1) / 2;
				updateLabelPos(labelMeshes.carbs, vLegY, vLegX, carbsT);
				labelMeshes.carbs.mesh.visible = showTip;

				// FIBER Label (Base)
				const fiberT = t / 2;
				updateLabelPos(labelMeshes.fiber, vLegY, vLegX, fiberT);
				labelMeshes.fiber.mesh.visible = showBase;

				// PROTEIN / HEDONIC Label Visibility
				// If Protein solid is gone (t=0, showBase=false), show HEDONIC
				if (labelMeshes.protein) {
					labelMeshes.protein.mesh.visible = showBase;
				}
				if (labelMeshes.hedonic) {
					// Show Hedonic ONLY if Protein is hidden (slider at max) AND we are refining
					labelMeshes.hedonic.mesh.visible = !showBase;
				}
			}

			function updateLabelPos(item, start, end, alpha) {
				const mesh = item.mesh;
				const mid = new THREE.Vector3().lerpVectors(start, end, alpha);
				const localPos = mid.clone().subScalar(offset); 
				
				const dist = item.dist || 0.2;
				const offsetVec = item.faceNormal.clone().multiplyScalar(dist);
				
				mesh.position.copy(localPos).add(offsetVec);
			}

			// DYNAMIC GEOMETRY UPDATE (Flattening)
			function updateGeometry() {
				// Calculate current Apex position
				// Moves from (0,0,0) towards (s/3, s/3, s/3) based on heightFactor
				// At factor 1.0 -> Apex at (0,0,0)
				// At factor 0.0 -> Apex at (s/3, s/3, s/3) (Base Center)
				const currentApex = new THREE.Vector3().copy(vBaseCenter).multiplyScalar(1 - heightFactor);
				
				// Shift by global offset since meshes are shifted
				const vertexPos = currentApex.clone().subScalar(offset);

				// Update Vertices for ALL solids
				// In createTetrahedron, Apex is always at indices 0, 3, 11 (first arg in triangle construction)
				Object.values(solids).forEach(mesh => {
					if(!mesh) return;
					const pos = mesh.geometry.attributes.position;
					// Update index 0
					pos.setXYZ(0, vertexPos.x, vertexPos.y, vertexPos.z);
					// Update index 3
					pos.setXYZ(3, vertexPos.x, vertexPos.y, vertexPos.z);
					// Update index 11
					pos.setXYZ(11, vertexPos.x, vertexPos.y, vertexPos.z);
					
					pos.needsUpdate = true;
					mesh.geometry.computeVertexNormals();
				});

				// Scale the Bisection Plane Height to match the Tetrahedron Height
				bisectionPlane.scale.y = heightFactor;

				// REMOVED: Dynamic Face Normal Recalculation for Labels
				// Labels will now stay in their original "Vertex Up" orientation/position.

				// Refresh Plane/Labels (Plane position might need update if logic depended on geometry, 
				// but currently plane moves based on slider t along fixed start/end vectors).
				updatePlanePosition();
			}

			function updatePlanePosition() {
				let t = 0;
				let isRefining = checkbox.checked;
				let isSnapped = false;
				let snappedValue = -1;

				if (isRefining) {
					// Normal Checked Logic
					let rawValue = parseFloat(slider.value);
					
					// Snap Logic
					for (let detent of DETENT_VALUES) {
						if (Math.abs(rawValue - detent) < SNAP_THRESHOLD) {
							rawValue = detent;
							slider.value = rawValue; 
							isSnapped = true;
							snappedValue = rawValue;
							break; 
						}
					}
					
					// CURVED MAPPING:
					// Normalize slider 0-100 to 0.0-1.0
					let normalizedInput = rawValue / 100;
					
					// Apply power curve so 0.5 becomes 0.333...
					t = Math.pow(normalizedInput, EXPONENT);
					
					// Update Plane Geometry for visual plane
					const startPos = new THREE.Vector3(0, s/2, s/2);
					const endPos = new THREE.Vector3(s, 0, 0);
					const lerpedPos = new THREE.Vector3().lerpVectors(startPos, endPos, t);
					const meshPos = lerpedPos.clone().subScalar(offset);
					bisectionPlane.position.copy(meshPos);
					currentLocalPlanePosition.copy(meshPos);
				}
				
				// Apply Snapped Visuals (Container Glow)
				if (isSnapped) {
					sliderContainer.classList.add('snapped');
				} else {
					sliderContainer.classList.remove('snapped');
				}

				// Apply Tick Glow
				ticks.forEach(tick => {
					if (isSnapped && parseFloat(tick.dataset.val) === snappedValue) {
						tick.classList.add('active');
					} else {
						tick.classList.remove('active');
					}
				});

				// Update Detent Text
				if (isSnapped) {
					switch(snappedValue) {
						case 0: detentText.innerText = "Satiety Score 0: Oreo cookies."; break;
						case 25: detentText.innerText = "Satiety Score 25: obesogenic diet."; break;
						case 50: detentText.innerText = "Satiety Score 50: perfect for most."; break;
						case 75: detentText.innerText = "Satiety Score 75: fitness model diet."; break;
						case 100: detentText.innerText = "Satiety Score 100: rabbit starvation."; break;
						default: detentText.innerText = "";
					}
				} else {
					detentText.innerText = "";
				}
				
				// Visibility Logic
				if (!isRefining) {
					// UNCHECKED STATE (Classic Mode)
					bisectionPlane.visible = false;
					
					// Hide Refinement Solids
					solids.fatTip.visible = false;
					solids.fatBase.visible = false;
					solids.carbsTip.visible = false;
					solids.carbsBase.visible = false;
					solids.protein.visible = false; 
					
					// Show Classic Solids
					solids.classicFat.visible = true;
					solids.classicCarbs.visible = true;
					solids.classicProtein.visible = true;
					
				} else {
					// CHECKED STATE (Refinement Mode)
					bisectionPlane.visible = (t > 0.01 && t < 0.99);
					
					// Hide Classic Solids
					solids.classicFat.visible = false;
					solids.classicCarbs.visible = false;
					solids.classicProtein.visible = false;
					
					// Show Refinement Solids (based on t)
					const showBase = (t > 0.02);
					const showTip = (t < 0.98);
					
					solids.fatBase.visible = showBase;
					solids.carbsBase.visible = showBase;
					solids.protein.visible = showBase; // The clipped protein
					
					solids.fatTip.visible = showTip;
					solids.carbsTip.visible = showTip;
				}

				updateLabels(t, isRefining);
			}

			checkbox.addEventListener('change', (e) => {
				if (e.target.checked) {
					sliderWrapper.style.display = 'block';
					// Set default to 50 (Visual Center, which is now Physical 1/3)
					slider.value = 50;
				} else {
					sliderWrapper.style.display = 'none';
					// Do not reset slider value here, updatePlanePosition handles the t=0.333 override
				}
				updatePlanePosition();
			});

			slider.addEventListener('input', updatePlanePosition);

			// Apply initial height factor
			updateGeometry();
			
			fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
				document.getElementById('loading').style.display = 'none';

				function createLabel(key, text, pStart, pEnd, colorHex, faceNormal, dist = 0.2) {
					const textGeo = new THREE.TextGeometry(text, {
						font: font,
						size: 0.25,
						height: 0.05,
						curveSegments: 12,
					});
					textGeo.center();
					
					const textMat = new THREE.MeshStandardMaterial({ 
						color: colorHex, 
						roughness: 0.2, 
						metalness: 0.2, 
						transparent: true,
						opacity: solidOpacity, 
						depthWrite: true,
						side: THREE.DoubleSide
					});

					const textMesh = new THREE.Mesh(textGeo, textMat);
					textMesh.castShadow = true;
					textMesh.receiveShadow = true;

					// --- ORIENTATION (Local Basis) ---
					const edgeLocal = new THREE.Vector3().subVectors(pStart, pEnd).normalize();
					const trueUp = new THREE.Vector3(-1, -1, -1).normalize();
					const forwardLocal = new THREE.Vector3().crossVectors(edgeLocal, trueUp).normalize();
					
					if (forwardLocal.dot(faceNormal) < 0) {
						forwardLocal.negate();
					}
					
					const rightLocal = new THREE.Vector3().crossVectors(trueUp, forwardLocal).normalize();

					const baseMat = new THREE.Matrix4();
					baseMat.makeBasis(rightLocal, trueUp, forwardLocal);
					const baseQuat = new THREE.Quaternion().setFromRotationMatrix(baseMat);

					pivotGroup.add(textMesh);
					
					labelMeshes[key] = {
						mesh: textMesh,
						baseQuat: baseQuat,
						dist: dist,
						faceNormal: faceNormal.clone() // Store CLONE so we can update it
					};
					
					updateLabelPos(labelMeshes[key], pStart, pEnd, 0.5);
				}

				const normalYZ = new THREE.Vector3(-1, 0, 0); 
				const normalXY = new THREE.Vector3(0, 0, -1); 
				const normalZX = new THREE.Vector3(0, -1, 0); 

				createLabel("protein", "PROTEIN", vLegY, vLegZ, 0x2962FF, normalYZ, 0.2);
				
				// CREATE HEDONIC LABEL (Same pos as Protein, Orange)
				createLabel("hedonic", "HEDONIC", vLegY, vLegZ, 0xFF9800, normalYZ, 0.2);

				createLabel("fat", "FAT", vLegZ, vLegX, 0xFFD600, normalZX);       
				createLabel("water", "WATER", vLegZ, vLegX, 0x40C4FF, normalZX);   
				
				createLabel("carbs", "CARBS", vLegX, vLegY, 0xFF1744, normalXY);   
				createLabel("fiber", "FIBER", vLegX, vLegY, 0x00E676, normalXY);   
				
				// INITIAL STATE:
				// Slider at 50 (Visual Center)
				// But checkbox is Unchecked by default
				slider.value = 50;
				updatePlanePosition();

			}, undefined, function(err) {
				console.error("Font error", err);
				document.getElementById('loading').innerText = "Error loading font";
			});


			// --- 7. Controls & Loop ---
			const controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;
			controls.enableKeys = false;
			
			// Disable Panning
			controls.enablePan = false;

			controls.maxPolarAngle = Math.PI / 2 + 0.2; 

			// ZOOM LIMITS
			controls.minDistance = 3; 
			controls.maxDistance = 30;

			const keyState = {};

			window.addEventListener('keydown', (e) => { 
				keyState[e.code] = true; 
				
				// Height Control Logic
				// Increased step size from 0.02 to 0.1 (5x faster)
				if (e.code === 'ArrowUp') {
					heightFactor = Math.min(1.0, heightFactor + 0.1);
					updateGeometry();
				}
				if (e.code === 'ArrowDown') {
					heightFactor = Math.max(0.01, heightFactor - 0.1);
					updateGeometry();
				}
			});
			window.addEventListener('keyup', (e) => { keyState[e.code] = false; });

			function animate() {
				if (!document.body.contains(renderer.domElement)) return;
				requestAnimationFrame(animate);

				const rotSpeed = 0.05;
				if (keyState.ArrowLeft)  rotateOnAxis(pivotGroup, new THREE.Vector3(0, 1, 0), -rotSpeed);
				if (keyState.ArrowRight) rotateOnAxis(pivotGroup, new THREE.Vector3(0, 1, 0), rotSpeed);
				// Removed Up/Down rotation logic to allow Height Control

				// --- DYNAMIC RENDER ORDER BASED ON CAMERA DISTANCE ---
				// Calculate center points for each solid in world space
				const getCenterWorld = (mesh) => {
					const box = new THREE.Box3().setFromObject(mesh);
					const center = new THREE.Vector3();
					box.getCenter(center);
					return center;
				};
				
				// Create array of solids with their distances
				const solidDistances = [];
				
				// Check which mode we're in and sort accordingly
				const isRefining = checkbox.checked;
				
				if (isRefining) {
					// Refinement mode solids
					if (solids.protein.visible) {
						solidDistances.push({ mesh: solids.protein, dist: camera.position.distanceTo(getCenterWorld(solids.protein)) });
					}
					if (solids.fatTip.visible) {
						solidDistances.push({ mesh: solids.fatTip, dist: camera.position.distanceTo(getCenterWorld(solids.fatTip)) });
					}
					if (solids.fatBase.visible) {
						solidDistances.push({ mesh: solids.fatBase, dist: camera.position.distanceTo(getCenterWorld(solids.fatBase)) });
					}
					if (solids.carbsTip.visible) {
						solidDistances.push({ mesh: solids.carbsTip, dist: camera.position.distanceTo(getCenterWorld(solids.carbsTip)) });
					}
					if (solids.carbsBase.visible) {
						solidDistances.push({ mesh: solids.carbsBase, dist: camera.position.distanceTo(getCenterWorld(solids.carbsBase)) });
					}
				} else {
					// Classic mode solids
					if (solids.classicProtein.visible) {
						solidDistances.push({ mesh: solids.classicProtein, dist: camera.position.distanceTo(getCenterWorld(solids.classicProtein)) });
					}
					if (solids.classicFat.visible) {
						solidDistances.push({ mesh: solids.classicFat, dist: camera.position.distanceTo(getCenterWorld(solids.classicFat)) });
					}
					if (solids.classicCarbs.visible) {
						solidDistances.push({ mesh: solids.classicCarbs, dist: camera.position.distanceTo(getCenterWorld(solids.classicCarbs)) });
					}
				}
				
				// Sort by distance (furthest first)
				solidDistances.sort((a, b) => b.dist - a.dist);
				
				// Assign renderOrder (furthest = lowest number = renders first)
				solidDistances.forEach((item, index) => {
					item.mesh.renderOrder = index;
				});

				// --- CAMERA-DEPENDENT TILT ---
				const polarAngle = controls.getPolarAngle();
				
				let tiltAngle = (Math.PI / 2) - polarAngle;
				tiltAngle = Math.max(-Math.PI/2, Math.min(Math.PI/2, tiltAngle));

				const tiltQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -tiltAngle);

				Object.values(labelMeshes).forEach(item => {
					if (item && item.mesh && item.mesh.visible) {
						item.mesh.quaternion.copy(item.baseQuat).multiply(tiltQuat);
					}
				});


				// --- CLIPPING PLANE UPDATE ---
				const normalLocal = new THREE.Vector3(2, -1, -1).normalize();
				const pointLocal = currentLocalPlanePosition.clone();

				const pointWorld = pointLocal.clone().applyMatrix4(pivotGroup.matrixWorld);
				const normalWorld = normalLocal.clone().transformDirection(pivotGroup.matrixWorld).normalize();

				globalPlaneTip.setFromNormalAndCoplanarPoint(normalWorld, pointWorld);
				const normalWorldNeg = normalWorld.clone().negate();
				globalPlaneBase.setFromNormalAndCoplanarPoint(normalWorldNeg, pointWorld);

				controls.update();
				renderer.render(scene, camera);
			}

			function rotateOnAxis(object, axis, angle) {
				const q = new THREE.Quaternion();
				q.setFromAxisAngle(axis, angle);
				object.quaternion.premultiply(q);
			}

			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});

			animate();
		})();
	</script>
</body>
</html>
