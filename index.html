<!DOCTYPE html>
<html lang="en">
<head>
	
	<!-- Custom Header Code For naiman.diet -->
	<meta name="keywords" content="satiety per calorie, satiety, SPC, ted naiman">
	<meta name="description" content="Satiety Per Calorie:  Eating, solved.  Book by Ted Naiman.">
	
	<link rel="canonical" href="https://www.naiman.diet" />
	
	<!-- Open Graph / Facebook -->
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://naiman.diet">
	<meta property="og:title" content="Satiety Per Calorie">
	<meta property="og:description" content="Satiety Per Calorie:  Eating, solved.  Book by Ted Naiman.">
	<meta property="og:image" content="https://naiman.diet/logo.jpg">
	<meta property="og:site_name" content="Satiety Per Calorie">
	<meta property="og:image:width" content="1200">
	<meta property="og:image:height" content="630">
	<meta property="og:locale" content="en_US"> 
	
	<!-- Twitter -->
	<meta property="twitter:card" content="summary_large_image">
	<meta property="twitter:url" content="https://naiman.diet">
	<meta property="twitter:title" content="Satiety Per Calorie">
	<meta property="twitter:description" content="Satiety Per Calorie:  Eating, solved.  Book by Ted Naiman.">
	<meta property="twitter:image" content="https://naiman.diet/logo.jpg">
	
	<meta name="author" content="Ted Naiman">
	

	
	<!-- Note: Relative favicon paths may not resolve in this environment -->
	<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
	<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
	<link rel="manifest" href="/site.webmanifest" />
	
	
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>Satiety Per Calorie Visualizer</title>
	
	<!-- Import Inter Font -->
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

	<style>
		/* Darker, sleek environment */
		body { margin: 0; overflow: hidden; background-color: #222; color: #eee; font-family: 'Inter', sans-serif; }
		canvas { display: block; width: 100vw; height: 100vh; outline: none; }
		
		#loading {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			font-size: 1.5em;
			pointer-events: none;
			transition: opacity 0.5s;
			color: #fff;
		}
		/* Slider Controls */
		#controls {
			position: absolute;
			bottom: 30px;
			width: 100%;
			display: flex;
			justify-content: center;
			align-items: center;
			pointer-events: auto; 
			z-index: 10;
		}
		.slider-container {
			/* UPDATED: Darker opacity (0.85) and removed hover effect */
			background: rgba(20, 20, 20, 0.6); 
			opacity: 0.85;
			
			padding: 15px 30px;
			border-radius: 30px;
			display: flex;
			flex-direction: column;
			align-items: center;
			backdrop-filter: blur(10px);
			box-shadow: 0 10px 30px rgba(0,0,0,0.5);
			border: 1px solid rgba(255,255,255,0.1);
			transition: all 0.3s ease;
		}
		
		/* Labels Row */
		.labels-row {
			display: flex;
			justify-content: space-between;
			width: 100%;
			margin-top: 8px; /* Changed from margin-bottom to margin-top */
			font-size: 0.8rem;
			color: #ccc;
			font-weight: 400; /* Changed from bold */
			text-transform: uppercase;
			letter-spacing: 0.5px;
		}
		.label-left { text-align: left; }
		.label-right { text-align: right; }
		
		/* Range Input & Ticks Styling */
		.range-holder {
			position: relative;
			width: 100%;
			height: 40px; /* Increased height for ticks */
			display: flex;
			align-items: center;
			justify-content: center;
		}
		
		/* --- CUSTOM SLIDER CSS FOR PERFECT ALIGNMENT --- */
		input[type=range] {
			-webkit-appearance: none; /* Remove default styling */
			width: 100%;
			background: transparent;
			margin: 0;
			cursor: pointer;
			position: relative;
			z-index: 2;
		}
		
		input[type=range]:focus {
			outline: none;
		}

		/* Webkit Thumb (Chrome/Safari/Edge) */
		input[type=range]::-webkit-slider-thumb {
			-webkit-appearance: none;
			height: 20px; /* FIXED WIDTH */
			width: 20px;  /* FIXED WIDTH */
			border-radius: 50%;
			background: #FF9800;
			cursor: pointer;
			margin-top: -8px; /* Offset to center on 4px track */
			box-shadow: 0 0 5px rgba(0,0,0,0.5);
			border: 2px solid #fff;
		}

		/* Firefox Thumb */
		input[type=range]::-moz-range-thumb {
			height: 20px; /* FIXED WIDTH */
			width: 20px;  /* FIXED WIDTH */
			border-radius: 50%;
			background: #FF9800;
			cursor: pointer;
			border: 2px solid #fff;
			box-shadow: 0 0 5px rgba(0,0,0,0.5);
		}

		/* Track Styling */
		input[type=range]::-webkit-slider-runnable-track {
			width: 100%;
			height: 4px;
			background: rgba(255, 255, 255, 0.2);
			border-radius: 2px;
			cursor: pointer;
		}
		
		input[type=range]::-moz-range-track {
			width: 100%;
			height: 4px;
			background: rgba(255, 255, 255, 0.2);
			border-radius: 2px;
			cursor: pointer;
		}
		
		.ticks-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: space-between;
			align-items: center;
			pointer-events: none;
			/* PADDING CALCULATION FOR PERFECT ALIGNMENT: */
			/* Thumb Width (20px) / 2  MINUS  Tick Width (2px) / 2 */
			/* 10px - 1px = 9px */
			padding: 0 9px; 
			box-sizing: border-box;
			z-index: 1;
		}
		
		.tick {
			width: 2px;
			height: 8px;
			background-color: #000;
			border: 1px solid #444;
			transform: translateY(-16px); /* Move below the thumb */
			transition: all 0.2s ease;
			border-radius: 2px;
			/* Ensure tick doesn't shrink in flex */
			flex-shrink: 0; 
		}
		
		.tick.active {
			background-color: #FF9800;
			border-color: #FF9800;
			box-shadow: 0 0 8px #FF9800, 0 0 12px #FF9800;
			/* REMOVED width/height changes to prevent layout jitter */
			/* height: 10px; */
			/* width: 3px; */
			
			/* Use Scale to grow visually from center without affecting layout positions */
			transform: translateY(-16px) scale(1.5, 1.4);
		}

		/* Checkbox Styling */
		.header-row {
			display: flex;
			align-items: center;
			gap: 10px;
			cursor: pointer;
			margin-top: 15px; /* Changed from margin-bottom to margin-top to separate from slider */
		}
		input[type=checkbox] {
			accent-color: #FF9800;
			width: 18px;
			height: 18px;
			cursor: pointer;
		}
		label {
			font-weight: 400; /* Changed from bold */
			color: #FF9800;
			font-size: 0.9rem;
			letter-spacing: 1px;
			text-transform: uppercase;
			cursor: pointer;
		}
		
		/* Logo button in top-left corner */
		#logo-button {
		  position: fixed;
		  top: 20px;
		  left: 20px;
		  z-index: 200;
		  width: 60px;
		  height: 60px;
		  cursor: pointer;
		  opacity: 0.75;
		  transition: opacity 0.3s ease, transform 0.3s ease, filter 0.3s ease;
		  pointer-events: auto;
		  border-radius: 8px;
		  padding: 8px;
		  background: rgba(20, 20, 20, 0.6);
		 // backdrop-filter: blur(10px);
		  border: 1px solid rgba(255, 255, 255, 0.1);
		  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
		}
		
		#logo-button:hover {
		  opacity: 1;
		  transform: scale(1.05);
		  filter: drop-shadow(0 0 8px rgba(125, 211, 252, 0.4));
		  border-color: rgba(125, 211, 252, 0.3);
		}
		
		#logo-button img {
		  width: 100%;
		  height: 100%;
		  object-fit: contain;
		  display: block;
		}

		/* --- NEW 2D/3D TOGGLE BUTTON --- */
		#mode-toggle {
			position: fixed;
			top: 20px;
			right: 20px;
			z-index: 200;
			
			/* UPDATED to match Logo Button opacity/color */
			background: rgba(20, 20, 20, 0.6);
			opacity: 0.75;
			
			backdrop-filter: blur(10px);
			border: 1px solid rgba(255, 255, 255, 0.1);
			color: #fff;
			padding: 12px 24px;
			border-radius: 30px;
			font-family: 'Inter', sans-serif;
			font-size: 0.85rem;
			font-weight: 700;
			cursor: pointer;
			text-transform: uppercase;
			letter-spacing: 1.5px;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
			transition: all 0.3s ease;
			display: flex;
			align-items: center;
			justify-content: center;
			user-select: none;
			-webkit-tap-highlight-color: transparent;
		}

		/* Only apply HOVER styles on devices that support hovering (Mouse/Desktop) */
		@media (hover: hover) {
			#mode-toggle:hover {
				opacity: 1; /* Brighten on hover */
				/* REMOVED: background: rgba(255, 255, 255, 0.1); */
				/* Now it keeps the dark background set in #mode-toggle */
				
				color: #fff;
				border-color: rgba(255, 255, 255, 0.5);
				transform: scale(1.05);
			}
		}
		
		/* Apply the visual glow when TAPPING (Active) on all devices */
		#mode-toggle:active {
			opacity: 1;
			/* REMOVED: background change here too for consistency */
			color: #fff;
			border-color: rgba(255, 255, 255, 0.5);
			transform: scale(0.95); /* Shrinks slightly for tactile click feel */
		}

	</style>
</head>
<body>
	
	<div id="loading">Loading Assets...</div>
	
	<!-- Logo button in top-left corner -->
	  <a id="logo-button" href="https://tednaiman.com">
		<img src="https://naiman.diet/SPCICON.PNG" alt="Satiety Per Calorie Icon Logo" onerror="this.style.display='none'; document.getElementById('logo-button').innerHTML='<span style=\'color:white; font-size:24px; display:flex; justify-content:center; align-items:center; height:100%;\'>SPC</span>'" />
	  </a>

	<!-- New 2D/3D Toggle Button -->
	<button id="mode-toggle">2D VIEW</button>

	<!-- Slider Control -->
	<div id="controls">
		<div class="slider-container">
			
			<div id="sliderWrapper" style="display: none; width: 300px;">
				<!-- 1. Text Placeholder Space -->
				<div id="detentText" style="width: 100%; text-align: center; margin-bottom: 15px; min-height: 1.2em; font-weight: 400; color: #fff; letter-spacing: 0.5px;"></div>

				<!-- 2. Slider Bar -->
				<div class="range-holder">
					<!-- Removed 'list' attribute to avoid native browser ticks interference -->
					<input type="range" id="planeSlider" min="0" max="100" value="0" step="0.01">
					<div class="ticks-container">
						<div class="tick" data-val="0"></div>
						<div class="tick" data-val="25"></div>
						<div class="tick" data-val="50"></div>
						<div class="tick" data-val="75"></div>
						<div class="tick" data-val="100"></div>
					</div>
				</div>

				<!-- 3. Directional Arrows -->
				<div class="labels-row">
					<div class="label-left">← Refinement</div>
					<div class="label-right">Satiety Per Calorie →</div>
				</div>
			</div>

			<!-- 4. Checkbox (Now at bottom) -->
			<div class="header-row">
				<input type="checkbox" id="refineCheck">
				<label for="refineCheck">REFINEMENT</label>
			</div>
			
		</div>
	</div>
	
	<!-- Three.js Library -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	<!-- OrbitControls -->
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
	<!-- FontLoader & TextGeometry -->
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

	<script>
		(function() {
			// --- 0. Cleanup Logic ---
			const existingCanvas = document.querySelector('canvas');
			if (existingCanvas) existingCanvas.remove();

			// --- 1. Scene Setup ---
			const scene = new THREE.Scene();
			const bgColor = 0x222222; 
			scene.background = new THREE.Color(bgColor);
			scene.fog = new THREE.Fog(bgColor, 15, 40);

			const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
			
			// --- CAMERA CONFIGURATION ---
			const START_RADIUS = 11.2;  // Distance from center
			
			// Polar Angle: 0 = Top Down, 90 (PI/2) = Horizon, 180 (PI) = Bottom Up
			const START_POLAR_ANGLE = THREE.MathUtils.degToRad(23.4); 
			
			// Azimuth Angle: Rotation around the equator
			const START_AZIMUTH_ANGLE = Math.atan2(6, 8); 

			// NEW: Vertical Shift as Percentage of Screen Height (0.1 = 10% shift up)
			// This moves the visual center UP without breaking the zoom/orbit center
			const VIEWPORT_OFFSET_PERCENT = 0.1; 

			// Calculate Cartesian Position (x, y, z)
			// Resetting target to 0,0,0 for correct physics
			camera.position.x = START_RADIUS * Math.sin(START_POLAR_ANGLE) * Math.sin(START_AZIMUTH_ANGLE);
			camera.position.y = START_RADIUS * Math.cos(START_POLAR_ANGLE);
			camera.position.z = START_RADIUS * Math.sin(START_POLAR_ANGLE) * Math.cos(START_AZIMUTH_ANGLE);


			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.localClippingEnabled = true; 
			renderer.shadowMap.enabled = true; 
			
			// UPDATED: Switch to PCFShadowMap (Standard) to allow for Sharp Shadows
			// PCFSoftShadowMap forces a blur, whereas PCFShadowMap respects radius 0.
			renderer.shadowMap.type = THREE.PCFShadowMap; 
			
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(window.devicePixelRatio);
			
			// Apply Initial View Offset (Lens Shift)
			function updateCameraOffset() {
				const fullWidth = window.innerWidth;
				const fullHeight = window.innerHeight;
				const offsetY = fullHeight * VIEWPORT_OFFSET_PERCENT;
				
				// setViewOffset( fullWidth, fullHeight, x, y, width, height )
				// We shift the 'window' down (positive Y) which forces the center UP relative to the frame
				camera.setViewOffset(fullWidth, fullHeight, 0, offsetY, fullWidth, fullHeight);
				camera.updateProjectionMatrix();
			}
			updateCameraOffset();
			
			renderer.domElement.setAttribute('tabindex', '0');
			renderer.domElement.style.outline = 'none'; 
			document.body.appendChild(renderer.domElement);
			renderer.domElement.focus();
			renderer.domElement.addEventListener('click', () => renderer.domElement.focus());
			renderer.domElement.addEventListener('mouseover', () => renderer.domElement.focus());

			// --- 2. Lighting ---
			
			// LIGHTING CONTROLS
			// Penumbra: 0.0 = Hard Edge, 1.0 = Soft/Diffused Edge
			const KEY_LIGHT_PENUMBRA = 1.0; 
			
			// Shadow Softness: 0 = Razor Sharp, 1+ = Softer
			// Now that we use PCFShadowMap, 0 will actually be sharp.
			const SHADOW_SOFTNESS = 6;


			const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
			hemiLight.position.set(0, 20, 0);
			scene.add(hemiLight);

			const spotLight = new THREE.SpotLight(0xffffff, 1.2);
			spotLight.position.set(0, 20, 0); 
			spotLight.angle = Math.PI / 6;
			
			// Apply Penumbra (Softness)
			spotLight.penumbra = KEY_LIGHT_PENUMBRA; 
			
			spotLight.decay = 2;
			spotLight.distance = 100;
			spotLight.castShadow = true;
			
			// UPDATED: Increased Map Size to 4096 (4K) for Ultra-HD Shadows
			spotLight.shadow.mapSize.width = 4096; 
			spotLight.shadow.mapSize.height = 4096;
			
			spotLight.shadow.bias = -0.0001;
			
			// Apply Shadow Softness
			spotLight.shadow.radius = SHADOW_SOFTNESS;
			
			scene.add(spotLight);

			const rimLight = new THREE.DirectionalLight(0xffffff, 0.4);
			rimLight.position.set(-5, 5, -5);
			scene.add(rimLight);

			const floorGeom = new THREE.PlaneGeometry(1000, 1000);
			const floorMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 1, metalness: 0 });
			const floor = new THREE.Mesh(floorGeom, floorMat);
			floor.rotation.x = -Math.PI / 2;
			floor.position.y = -4.5; 
			floor.receiveShadow = true; 
			scene.add(floor);

			// --- GRID HELPER (Graph Paper Motif) ---
			// Size: 200, Divisions: 100 (creates 2x2 unit squares)
			const gridHelper = new THREE.GridHelper(200, 100, 0x000000, 0x000000);
			gridHelper.position.y = -4.49; // Slightly above floor to prevent z-fighting
			gridHelper.material.opacity = 0.15; // Very faint opacity
			gridHelper.material.transparent = true;
			
			// ALIGNMENT FIX:
			// Sync grid rotation to Camera Azimuth so lines appear horizontal
			gridHelper.rotation.y = START_AZIMUTH_ANGLE;
			
			scene.add(gridHelper);


			// --- 3. Asset Loading ---
			const fontLoader = new THREE.FontLoader();

			// --- 4. Geometry Construction ---
			const s = 2.5; 
			const offset = s / 4; 
			
			// Height Factor for Dynamic Flattening
			let heightFactor = 0.5; // Current visual height
			let targetHeightFactor = 0.5; // Target for animation

			const vApex = new THREE.Vector3(0, 0, 0); 
			const vLegX = new THREE.Vector3(s, 0, 0); 
			const vLegY = new THREE.Vector3(0, s, 0); 
			const vLegZ = new THREE.Vector3(0, 0, s); 
			const vBaseCenter = new THREE.Vector3(s/3, s/3, s/3); 
			
			// New Midpoint for Mega Solids (Midpoint of Y-Z edge)
			const vMidYZ = new THREE.Vector3(0, s/2, s/2);

			const globalPlaneTip = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
			const globalPlaneBase = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0);

			function createTetrahedron(pApex, pLeg1, pLeg2, pBase, colorHex, clippingPlanesArray, opacity = 0.5) {
				const geom = new THREE.BufferGeometry();
				const vertices = [
					pApex.x, pApex.y, pApex.z,  pLeg1.x, pLeg1.y, pLeg1.z,  pLeg2.x, pLeg2.y, pLeg2.z,
					pApex.x, pApex.y, pApex.z,  pBase.x, pBase.y, pBase.z,  pLeg1.x, pLeg1.y, pLeg1.z,
					pLeg1.x, pLeg1.y, pLeg1.z,  pBase.x, pBase.y, pBase.z,  pLeg2.x, pLeg2.y, pLeg2.z,
					pLeg2.x, pLeg2.y, pLeg2.z,  pBase.x, pBase.y, pBase.z,  pApex.x, pApex.y, pApex.z
				];

				geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
				geom.computeVertexNormals();
				geom.translate(-offset, -offset, -offset);

				const material = new THREE.MeshStandardMaterial({ 
					color: colorHex, 
					roughness: 0.2, 
					metalness: 0.2, 
					flatShading: true,
					side: THREE.DoubleSide,
					clippingPlanes: clippingPlanesArray || [], 
					clipShadows: true,
					transparent: true,
					opacity: opacity, 
					depthWrite: false,
					depthTest: true
				});
				
				const mesh = new THREE.Mesh(geom, material);
				mesh.castShadow = true; 
				mesh.receiveShadow = true; 
				return mesh;
			}

			const pivotGroup = new THREE.Group();
			scene.add(pivotGroup);

			// Store mesh references
			const solids = {
				// Refinement Mode Solids (5-Part Logic)
				protein: null,
				fatTip: null,
				fatBase: null,
				carbsTip: null,
				carbsBase: null,
				
				// Classic Mode Solids (3-Part Logic, 1/3 each)
				classicProtein: null,
				classicFat: null,
				classicCarbs: null
			};

			// Single opacity value for all solids
			const solidOpacity = 0.5;

			// --- CONSTRUCT REFINEMENT PARTS (The "Mega" Solids for Slider Logic) ---
			
			// PROTEIN (Clipped by base plane)
			solids.protein = createTetrahedron(vApex, vLegY, vLegZ, vBaseCenter, 0x2962FF, [globalPlaneBase], solidOpacity); 
			
			// FAT (Tip extends to mid-YZ, Base is normal)
			solids.fatTip = createTetrahedron(vApex, vLegZ, vLegX, vMidYZ, 0xFFD600, [globalPlaneTip], solidOpacity); 
			solids.fatBase = createTetrahedron(vApex, vLegZ, vLegX, vBaseCenter, 0x40C4FF, [globalPlaneBase], solidOpacity); 

			// CARBS (Tip extends to mid-YZ, Base is normal)
			solids.carbsTip = createTetrahedron(vApex, vLegX, vLegY, vMidYZ, 0xFF1744, [globalPlaneTip], solidOpacity); 
			solids.carbsBase = createTetrahedron(vApex, vLegX, vLegY, vBaseCenter, 0x00E676, [globalPlaneBase], solidOpacity); 

			// --- CONSTRUCT CLASSIC PARTS (Standard 1/3 Split) ---
			// These use vBaseCenter as the meeting point for all three
			
			// Classic Protein (Blue)
			solids.classicProtein = createTetrahedron(vApex, vLegY, vLegZ, vBaseCenter, 0x2962FF, [], solidOpacity);
			
			// Classic Fat (Yellow)
			solids.classicFat = createTetrahedron(vApex, vLegZ, vLegX, vBaseCenter, 0xFFD600, [], solidOpacity);
			
			// Classic Carbs (Red)
			solids.classicCarbs = createTetrahedron(vApex, vLegX, vLegY, vBaseCenter, 0xFF1744, [], solidOpacity);


			// Add all to scene
			pivotGroup.add(solids.protein);
			pivotGroup.add(solids.fatTip);
			pivotGroup.add(solids.fatBase);
			pivotGroup.add(solids.carbsTip);
			pivotGroup.add(solids.carbsBase);
			
			pivotGroup.add(solids.classicProtein);
			pivotGroup.add(solids.classicFat);
			pivotGroup.add(solids.classicCarbs);

			// Orient Vertex Up (Standard starting pose)
			const cornerDirection = new THREE.Vector3(-1, -1, -1).normalize();
			const upDirection = new THREE.Vector3(0, 1, 0);
			pivotGroup.quaternion.setFromUnitVectors(cornerDirection, upDirection);

			// --- OPTIONAL: ADJUST STARTING ROTATION ---
			// Change this value to rotate the object on startup.
			// 52 deg = Yellow (Fat). 52 + 120 = 172 deg = Blue (Protein).
			const INITIAL_ROTATION_OFFSET = THREE.MathUtils.degToRad(-22); 
			
			// CORRECTED: Apply rotation around the WORLD Vertical Axis (0,1,0)
			const initialRotQ = new THREE.Quaternion();
			initialRotQ.setFromAxisAngle(new THREE.Vector3(0, 1, 0), INITIAL_ROTATION_OFFSET);
			pivotGroup.quaternion.premultiply(initialRotQ);


			// --- 5. Bisection Plane Mesh ---
			const planeWidth = s * Math.sqrt(2);
			const planeHeight = s / Math.sqrt(3);
			const planeGeom = new THREE.PlaneGeometry(planeWidth, planeHeight); 
			planeGeom.translate(0, planeHeight / 2, 0); 

			const planeMat = new THREE.MeshBasicMaterial({ 
				color: 0xffffff, 
				side: THREE.DoubleSide, 
				transparent: true, 
				opacity: 0.15, 
				depthWrite: false, 
			});
			const bisectionPlane = new THREE.Mesh(planeGeom, planeMat);
			bisectionPlane.raycast = function() {}; 

			const borderGeom = new THREE.EdgesGeometry(planeGeom);
			const borderMat = new THREE.LineBasicMaterial({ color: 0xFF9800, transparent: true, opacity: 0.8 });
			const border = new THREE.LineSegments(borderGeom, borderMat);
			border.raycast = function() {}; 
			bisectionPlane.add(border);

			bisectionPlane.renderOrder = 999;
			pivotGroup.add(bisectionPlane);

			const localUp = new THREE.Vector3(-1, -1, -1).normalize(); 
			const localNormal = new THREE.Vector3(2, -1, -1).normalize();
			const localRight = new THREE.Vector3().crossVectors(localUp, localNormal).normalize();
			const correctedUp = new THREE.Vector3().crossVectors(localNormal, localRight).normalize();
			const planeMatrix = new THREE.Matrix4();
			planeMatrix.makeBasis(localRight, correctedUp, localNormal);
			bisectionPlane.rotation.setFromRotationMatrix(planeMatrix);

			
			// --- 6. 3D Text Legends & Update Logic ---
			
			const labelMeshes = {
				fat: null,
				water: null,
				carbs: null,
				fiber: null,
				protein: null,
				hedonic: null // Added Hedonic
			};

			const slider = document.getElementById('planeSlider');
			const checkbox = document.getElementById('refineCheck');
			const sliderWrapper = document.getElementById('sliderWrapper');
			const sliderContainer = document.querySelector('.slider-container');
			const ticks = document.querySelectorAll('.tick');
			const detentText = document.getElementById('detentText');
			let currentLocalPlanePosition = new THREE.Vector3();

			// EXPONENTIAL CURVE SETTINGS
			// We want Slider(0.5) to equal T(1/3).
			// Formula: y = x^k
			// 1/3 = 0.5^k  =>  ln(1/3) = k * ln(0.5)  => k = ln(1/3)/ln(0.5) ≈ 1.58496
			const EXPONENT = Math.log(1/3) / Math.log(0.5);
			
			// SNAP SETTINGS (Now snapping at visual 0, 25, 50, 75, 100)
			const DETENT_VALUES = [0, 25, 50, 75, 100]; 
			const SNAP_THRESHOLD = 2.0; 

			function updateLabels(t, isRefining) {
				if (!labelMeshes.fat) return;

				// If not refining (Unchecked), show only core macros
				if (!isRefining) {
					labelMeshes.fat.mesh.visible = true;
					labelMeshes.carbs.mesh.visible = true;
					labelMeshes.protein.mesh.visible = true;
					
					labelMeshes.water.mesh.visible = false;
					labelMeshes.fiber.mesh.visible = false;
					if (labelMeshes.hedonic) labelMeshes.hedonic.mesh.visible = false; // Hide Hedonic
					
					// Position labels at "Classic" locations
					updateLabelPos(labelMeshes.fat, vLegZ, vLegX, 0.5);
					updateLabelPos(labelMeshes.carbs, vLegY, vLegX, 0.5);
					
					return;
				}

				// Normal logic when refining
				const showBase = (t > 0.02);
				const showTip = (t < 0.98);

				// FAT Label (Tip)
				const fatT = (t + 1) / 2;
				updateLabelPos(labelMeshes.fat, vLegZ, vLegX, fatT);
				labelMeshes.fat.mesh.visible = showTip;

				// WATER Label (Base)
				const waterT = t / 2;
				updateLabelPos(labelMeshes.water, vLegZ, vLegX, waterT);
				labelMeshes.water.mesh.visible = showBase;

				// CARBS Label (Tip)
				const carbsT = (t + 1) / 2;
				updateLabelPos(labelMeshes.carbs, vLegY, vLegX, carbsT);
				labelMeshes.carbs.mesh.visible = showTip;

				// FIBER Label (Base)
				const fiberT = t / 2;
				updateLabelPos(labelMeshes.fiber, vLegY, vLegX, fiberT);
				labelMeshes.fiber.mesh.visible = showBase;

				// PROTEIN / HEDONIC Label Visibility
				// If Protein solid is gone (t=0, showBase=false), show HEDONIC
				if (labelMeshes.protein) {
					labelMeshes.protein.mesh.visible = showBase;
				}
				if (labelMeshes.hedonic) {
					// Show Hedonic ONLY if Protein is hidden (slider at max) AND we are refining
					labelMeshes.hedonic.mesh.visible = !showBase;
				}
			}

			function updateLabelPos(item, start, end, alpha) {
				const mesh = item.mesh;
				const mid = new THREE.Vector3().lerpVectors(start, end, alpha);
				const localPos = mid.clone().subScalar(offset); 
				
				const dist = item.dist || 0.2;
				const offsetVec = item.faceNormal.clone().multiplyScalar(dist);
				
				mesh.position.copy(localPos).add(offsetVec);
			}

			// DYNAMIC GEOMETRY UPDATE (Flattening)
			function updateGeometry() {
				// Calculate current Apex position
				// Moves from (0,0,0) towards (s/3, s/3, s/3) based on heightFactor
				// At factor 1.0 -> Apex at (0,0,0)
				// At factor 0.0 -> Apex at (s/3, s/3, s/3) (Base Center)
				const currentApex = new THREE.Vector3().copy(vBaseCenter).multiplyScalar(1 - heightFactor);
				
				// Shift by global offset since meshes are shifted
				const vertexPos = currentApex.clone().subScalar(offset);

				// Update Vertices for ALL solids
				// In createTetrahedron, Apex is always at indices 0, 3, 11 (first arg in triangle construction)
				Object.values(solids).forEach(mesh => {
					if(!mesh) return;
					const pos = mesh.geometry.attributes.position;
					// Update index 0
					pos.setXYZ(0, vertexPos.x, vertexPos.y, vertexPos.z);
					// Update index 3
					pos.setXYZ(3, vertexPos.x, vertexPos.y, vertexPos.z);
					// Update index 11
					pos.setXYZ(11, vertexPos.x, vertexPos.y, vertexPos.z);
					
					pos.needsUpdate = true;
					mesh.geometry.computeVertexNormals();
				});

				// Scale the Bisection Plane Height to match the Tetrahedron Height
				// Avoid scale 0 error
				bisectionPlane.scale.y = Math.max(0.001, heightFactor);

				// REMOVED: Dynamic Face Normal Recalculation for Labels
				// Labels will now stay in their original "Vertex Up" orientation/position.

				// Refresh Plane/Labels (Plane position might need update if logic depended on geometry, 
				// but currently plane moves based on slider t along fixed start/end vectors).
				updatePlanePosition();
			}

			function updatePlanePosition() {
				let t = 0;
				let isRefining = checkbox.checked;
				let isSnapped = false;
				let snappedValue = -1;

				if (isRefining) {
					// Normal Checked Logic
					let rawValue = parseFloat(slider.value);
					
					// Snap Logic
					for (let detent of DETENT_VALUES) {
						if (Math.abs(rawValue - detent) < SNAP_THRESHOLD) {
							rawValue = detent;
							slider.value = rawValue; 
							isSnapped = true;
							snappedValue = rawValue;
							break; 
						}
					}
					
					// CURVED MAPPING:
					// Normalize slider 0-100 to 0.0-1.0
					let normalizedInput = rawValue / 100;
					
					// Apply power curve so 0.5 becomes 0.333...
					t = Math.pow(normalizedInput, EXPONENT);
					
					// Update Plane Geometry for visual plane
					const startPos = new THREE.Vector3(0, s/2, s/2);
					const endPos = new THREE.Vector3(s, 0, 0);
					const lerpedPos = new THREE.Vector3().lerpVectors(startPos, endPos, t);
					const meshPos = lerpedPos.clone().subScalar(offset);
					bisectionPlane.position.copy(meshPos);
					currentLocalPlanePosition.copy(meshPos);
				}
				
				// Apply Tick Glow (Container Glow Removed)
				ticks.forEach(tick => {
					if (isSnapped && parseFloat(tick.dataset.val) === snappedValue) {
						tick.classList.add('active');
					} else {
						tick.classList.remove('active');
					}
				});

				// Update Detent Text
				if (isSnapped) {
					switch(snappedValue) {
						case 0: detentText.innerText = "Satiety Score 0: Oreo cookies."; break;
						case 25: detentText.innerText = "Satiety Score 25: obesogenic diet."; break;
						case 50: detentText.innerText = "Satiety Score 50: perfect for most."; break;
						case 75: detentText.innerText = "Satiety Score 75: fitness model diet."; break;
						case 100: detentText.innerText = "Satiety Score 100: rabbit starvation."; break;
						default: detentText.innerText = "";
					}
				} else {
					detentText.innerText = "";
				}
				
				// Visibility Logic
				if (!isRefining) {
					// UNCHECKED STATE (Classic Mode)
					bisectionPlane.visible = false;
					
					// Hide Refinement Solids
					solids.fatTip.visible = false;
					solids.fatBase.visible = false;
					solids.carbsTip.visible = false;
					solids.carbsBase.visible = false;
					solids.protein.visible = false; 
					
					// Show Classic Solids
					solids.classicFat.visible = true;
					solids.classicCarbs.visible = true;
					solids.classicProtein.visible = true;
					
				} else {
					// CHECKED STATE (Refinement Mode)
					bisectionPlane.visible = (t > 0.01 && t < 0.99);
					
					// Hide Classic Solids
					solids.classicFat.visible = false;
					solids.classicCarbs.visible = false;
					solids.classicProtein.visible = false;
					
					// Show Refinement Solids (based on t)
					const showBase = (t > 0.02);
					const showTip = (t < 0.98);
					
					solids.fatBase.visible = showBase;
					solids.carbsBase.visible = showBase;
					solids.protein.visible = showBase; // The clipped protein
					
					solids.fatTip.visible = showTip;
					solids.carbsTip.visible = showTip;
				}

				updateLabels(t, isRefining);
			}

			checkbox.addEventListener('change', (e) => {
				if (e.target.checked) {
					sliderWrapper.style.display = 'block';
					// Set default to 50 (Visual Center, which is now Physical 1/3)
					slider.value = 50;
				} else {
					sliderWrapper.style.display = 'none';
					// Do not reset slider value here, updatePlanePosition handles the t=0.333 override
				}
				updatePlanePosition();
			});

			slider.addEventListener('input', updatePlanePosition);

			// Apply initial height factor
			updateGeometry();
			
			fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
				document.getElementById('loading').style.display = 'none';

				function createLabel(key, text, pStart, pEnd, colorHex, faceNormal, dist = 0.2) {
					const textGeo = new THREE.TextGeometry(text, {
						font: font,
						size: 0.25,
						height: 0.05,
						curveSegments: 12,
					});
					textGeo.center();
					
					const textMat = new THREE.MeshStandardMaterial({ 
						color: colorHex, 
						roughness: 0.2, 
						metalness: 0.2, 
						transparent: true,
						opacity: solidOpacity, 
						depthWrite: true,
						side: THREE.DoubleSide
					});

					const textMesh = new THREE.Mesh(textGeo, textMat);
					textMesh.castShadow = true;
					textMesh.receiveShadow = true;

					// --- ORIENTATION (Local Basis) ---
					const edgeLocal = new THREE.Vector3().subVectors(pStart, pEnd).normalize();
					const trueUp = new THREE.Vector3(-1, -1, -1).normalize();
					const forwardLocal = new THREE.Vector3().crossVectors(edgeLocal, trueUp).normalize();
					
					if (forwardLocal.dot(faceNormal) < 0) {
						forwardLocal.negate();
					}
					
					const rightLocal = new THREE.Vector3().crossVectors(trueUp, forwardLocal).normalize();

					const baseMat = new THREE.Matrix4();
					baseMat.makeBasis(rightLocal, trueUp, forwardLocal);
					const baseQuat = new THREE.Quaternion().setFromRotationMatrix(baseMat);

					pivotGroup.add(textMesh);
					
					labelMeshes[key] = {
						mesh: textMesh,
						baseQuat: baseQuat,
						dist: dist,
						faceNormal: faceNormal.clone() // Store CLONE so we can update it
					};
					
					updateLabelPos(labelMeshes[key], pStart, pEnd, 0.5);
				}

				const normalYZ = new THREE.Vector3(-1, 0, 0); 
				const normalXY = new THREE.Vector3(0, 0, -1); 
				const normalZX = new THREE.Vector3(0, -1, 0); 

				createLabel("protein", "PROTEIN", vLegY, vLegZ, 0x2962FF, normalYZ, 0.2);
				
				// CREATE HEDONIC LABEL (Same pos as Protein, Orange)
				createLabel("hedonic", "HEDONIC", vLegY, vLegZ, 0xFF9800, normalYZ, 0.2);

				createLabel("fat", "FAT", vLegZ, vLegX, 0xFFD600, normalZX);       
				createLabel("water", "WATER", vLegZ, vLegX, 0x40C4FF, normalZX);   
				
				createLabel("carbs", "CARBS", vLegX, vLegY, 0xFF1744, normalXY);   
				createLabel("fiber", "FIBER", vLegX, vLegY, 0x00E676, normalXY);   
				
				// INITIAL STATE:
				// Slider at 50 (Visual Center)
				// But checkbox is Unchecked by default
				slider.value = 50;
				updatePlanePosition();

			}, undefined, function(err) {
				console.error("Font error", err);
				document.getElementById('loading').innerText = "Error loading font";
			});


			// --- 7. Controls & Loop ---
			const controls = new THREE.OrbitControls(camera, renderer.domElement);
			
			// Reset target to Center of Object (0,0,0) so Zoom/Spin works perfectly
			controls.target.set(0, 0, 0);
			
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;
			controls.enableKeys = false;
			
			// Disable Panning to keep object centered
			controls.enablePan = false;

			// UNMAP Right Click from OrbitControls so we can use it for Object Rotation
			controls.mouseButtons = {
				LEFT: THREE.MOUSE.ROTATE,
				MIDDLE: THREE.MOUSE.DOLLY,
				RIGHT: null 
			};

			// ZOOM LIMITS
			controls.minDistance = 3; 
			controls.maxDistance = 30;

			const keyState = {};
			
			// --- PHYSICS VARIABLES ---
			let angularVelocity = 0;
			const ROTATION_ACCEL = 0.000009; 
			const ROTATION_FRICTION = 0.9998; 
			const MAX_VELOCITY = 0.003; 
			
			// INTERACTION VARIABLES
			let isRightDragging = false;
			let lastPointerX = 0;
			let lastPointerY = 0;
			const DRAG_SENSITIVITY = 0.00005; 
			const HEIGHT_SENSITIVITY = 0.005;
			
			// GESTURE LOCKING VARIABLES
			let lockedGesture = null; // Can be: 'rotate', 'height', 'pinch', or null
			let initialTouchDistance = 0;
			let gestureStartX = 0;
			let gestureStartY = 0;
			let movementAccumulated = 0;
			const GESTURE_LOCK_THRESHOLD = 15; // pixels of movement before locking
			
			// FLOOR LIMIT for Dynamic Camera Logic
			const FLOOR_Y_LIMIT = 4.2;

			// 1. Prevent Context Menu on Right Click
			renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

			// 2. POINTER EVENTS
			function syncModeButton() {
				const modeToggleBtn = document.getElementById('mode-toggle');
				if (targetHeightFactor <= 0.05) { 
					modeToggleBtn.innerText = "3D VIEW"; 
					modeToggleBtn.style.color = "#FF9800";
				} else {
					modeToggleBtn.innerText = "2D VIEW"; 
					modeToggleBtn.style.color = "#fff";
				}
			}

			renderer.domElement.addEventListener('pointerdown', (e) => {
				if (e.button === 2 || e.pointerType === 'touch' && e.isPrimary === false) {
					isRightDragging = true;
					lastPointerX = e.clientX;
					lastPointerY = e.clientY;
					
					// Initialize gesture locking for desktop/trackpad
					gestureStartX = e.clientX;
					gestureStartY = e.clientY;
					lockedGesture = null;
					movementAccumulated = 0;
					
					renderer.domElement.setPointerCapture(e.pointerId);
				}
			});

			renderer.domElement.addEventListener('pointermove', (e) => {
				if (isRightDragging) {
					const deltaX = e.clientX - lastPointerX;
					const deltaY = e.clientY - lastPointerY;
					
					// If gesture not yet locked, determine which gesture to lock to
					if (lockedGesture === null) {
						// Accumulate total movement from start
						const totalDeltaX = Math.abs(e.clientX - gestureStartX);
						const totalDeltaY = Math.abs(e.clientY - gestureStartY);
						
						movementAccumulated = Math.max(totalDeltaX, totalDeltaY);
						
						// Once movement exceeds threshold, lock to dominant gesture
						if (movementAccumulated > GESTURE_LOCK_THRESHOLD) {
							if (totalDeltaX > totalDeltaY * 1.5) {
								// Horizontal movement is dominant - rotation
								lockedGesture = 'rotate';
							} else if (totalDeltaY > totalDeltaX * 1.5) {
								// Vertical movement is dominant - height
								lockedGesture = 'height';
							}
							// Note: if movements are too similar, we wait for more movement
						}
					}
					
					// Apply only the locked gesture (or all if not yet locked)
					if (lockedGesture === null) {
						// Before locking, apply all gestures (but minimal since we're under threshold)
						angularVelocity += deltaX * DRAG_SENSITIVITY;
						targetHeightFactor -= deltaY * HEIGHT_SENSITIVITY;
						targetHeightFactor = Math.max(0.01, Math.min(1.0, targetHeightFactor));
					} else if (lockedGesture === 'rotate') {
						// Only apply rotation
						angularVelocity += deltaX * DRAG_SENSITIVITY;
					} else if (lockedGesture === 'height') {
						// Only apply height adjustment
						targetHeightFactor -= deltaY * HEIGHT_SENSITIVITY;
						targetHeightFactor = Math.max(0.01, Math.min(1.0, targetHeightFactor));
					}
					
					syncModeButton();

					lastPointerX = e.clientX;
					lastPointerY = e.clientY;
				}
			});

			renderer.domElement.addEventListener('pointerup', (e) => {
				if (isRightDragging) {
					isRightDragging = false;
					lockedGesture = null; // Reset gesture lock
					movementAccumulated = 0;
					renderer.domElement.releasePointerCapture(e.pointerId);
				}
			});

			// 3. Touch Events
			renderer.domElement.addEventListener('touchstart', (e) => {
				if (e.touches.length === 2) {
					isRightDragging = true;
					
					// Calculate midpoint
					lastPointerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
					lastPointerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
					
					// Store starting position for gesture detection
					gestureStartX = lastPointerX;
					gestureStartY = lastPointerY;
					
					// Calculate initial distance between touches for pinch detection
					const dx = e.touches[1].clientX - e.touches[0].clientX;
					const dy = e.touches[1].clientY - e.touches[0].clientY;
					initialTouchDistance = Math.sqrt(dx * dx + dy * dy);
					
					// Reset gesture lock
					lockedGesture = null;
					movementAccumulated = 0;
				}
			});

			renderer.domElement.addEventListener('touchmove', (e) => {
				if (isRightDragging && e.touches.length === 2) {
					const currentX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
					const currentY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
					
					const deltaX = currentX - lastPointerX;
					const deltaY = currentY - lastPointerY;
					
					// Calculate current distance for pinch detection
					const dx = e.touches[1].clientX - e.touches[0].clientX;
					const dy = e.touches[1].clientY - e.touches[0].clientY;
					const currentDistance = Math.sqrt(dx * dx + dy * dy);
					const pinchDelta = currentDistance - initialTouchDistance;
					
					// If gesture not yet locked, determine which gesture to lock to
					if (lockedGesture === null) {
						// Accumulate total movement from start
						const totalDeltaX = Math.abs(currentX - gestureStartX);
						const totalDeltaY = Math.abs(currentY - gestureStartY);
						const totalPinchDelta = Math.abs(pinchDelta);
						
						movementAccumulated = Math.max(totalDeltaX, totalDeltaY, totalPinchDelta);
						
						// Once movement exceeds threshold, lock to dominant gesture
						if (movementAccumulated > GESTURE_LOCK_THRESHOLD) {
							// Determine which gesture is dominant
							if (totalPinchDelta > totalDeltaX && totalPinchDelta > totalDeltaY) {
								lockedGesture = 'pinch';
							} else if (totalDeltaX > totalDeltaY * 1.5) {
								// Horizontal movement is dominant - rotation
								lockedGesture = 'rotate';
							} else if (totalDeltaY > totalDeltaX * 1.5) {
								// Vertical movement is dominant - height
								lockedGesture = 'height';
							}
							// Note: if movements are too similar, we wait for more movement
						}
					}
					
					// Apply only the locked gesture (or all if not yet locked)
					if (lockedGesture === null) {
						// Before locking, apply all gestures (but minimal since we're under threshold)
						angularVelocity += deltaX * DRAG_SENSITIVITY;
						targetHeightFactor -= deltaY * HEIGHT_SENSITIVITY;
						targetHeightFactor = Math.max(0.01, Math.min(1.0, targetHeightFactor));
					} else if (lockedGesture === 'rotate') {
						// Only apply rotation
						angularVelocity += deltaX * DRAG_SENSITIVITY;
					} else if (lockedGesture === 'height') {
						// Only apply height adjustment
						targetHeightFactor -= deltaY * HEIGHT_SENSITIVITY;
						targetHeightFactor = Math.max(0.01, Math.min(1.0, targetHeightFactor));
					} else if (lockedGesture === 'pinch') {
						// Apply pinch-to-zoom (adjust camera distance via OrbitControls)
						// Negative because pinching in should zoom in (decrease distance)
						const zoomSensitivity = 0.01;
						const currentDist = camera.position.distanceTo(controls.target);
						const newDist = currentDist - (pinchDelta * zoomSensitivity);
						const clampedDist = Math.max(controls.minDistance, Math.min(controls.maxDistance, newDist));
						
						// Update camera position to new distance
						const direction = camera.position.clone().sub(controls.target).normalize();
						camera.position.copy(controls.target).add(direction.multiplyScalar(clampedDist));
						
						// Update initial distance for next frame
						initialTouchDistance = currentDistance;
					}
					
					syncModeButton();

					lastPointerX = currentX;
					lastPointerY = currentY;
				}
			});

			renderer.domElement.addEventListener('touchend', (e) => {
				if (e.touches.length < 2) {
					isRightDragging = false;
					lockedGesture = null; // Reset gesture lock
					movementAccumulated = 0;
				}
			});


			window.addEventListener('keydown', (e) => { 
				keyState[e.code] = true; 
				if (e.code === 'ArrowUp') targetHeightFactor = Math.min(1.0, targetHeightFactor + 0.1);
				if (e.code === 'ArrowDown') targetHeightFactor = Math.max(0.01, targetHeightFactor - 0.1);
				syncModeButton();
			});
			window.addEventListener('keyup', (e) => { keyState[e.code] = false; });
			
			const modeToggleBtn = document.getElementById('mode-toggle');
			modeToggleBtn.addEventListener('click', () => {
				if (targetHeightFactor > 0.05) {
					targetHeightFactor = 0.01; 
					modeToggleBtn.innerText = "3D VIEW"; 
					modeToggleBtn.style.color = "#FF9800";
				} else {
					targetHeightFactor = 0.5; 
					modeToggleBtn.innerText = "2D VIEW"; 
					modeToggleBtn.style.color = "#fff";
				}
			});


			function animate() {
				if (!document.body.contains(renderer.domElement)) return;
				requestAnimationFrame(animate);

				// --- DYNAMIC CAMERA LIMITS (Bidirectional Floor Guard) ---
				if (controls) {
					const currentDist = camera.position.distanceTo(controls.target);
					const currentPolar = controls.getPolarAngle();
					
					// Safety check
					const dist = Math.max(0.1, currentDist);

					// 1. RADIUS LIMITS ROTATION (Prevent clipping when orbiting)
					if (dist < FLOOR_Y_LIMIT) {
						controls.maxPolarAngle = Math.PI; // Allow full underneath rotation
					} else {
						// Calculate the angle where the sphere hits the floor
						let ratio = -FLOOR_Y_LIMIT / dist;
						ratio = Math.max(-1, Math.min(1, ratio));
						controls.maxPolarAngle = Math.acos(ratio);
					}

					// 2. ROTATION LIMITS ZOOM (Prevent clipping when zooming out)
					// If we are looking from below (angle > 90 deg), cap the max zoom distance
					if (currentPolar > Math.PI / 2) {
						// Geometric Limit: r_max = -FloorY / cos(theta)
						// Note: cos(theta) is negative here, so the result is positive
						// We use a tiny epsilon (0.001) to prevent divide-by-zero flickering at exact 90 deg
						const cosTheta = Math.min(-0.001, Math.cos(currentPolar));
						const maxAllowedDistance = -FLOOR_Y_LIMIT / cosTheta;
						
						// Apply limit, but never exceed the global max (30)
						controls.maxDistance = Math.min(30, maxAllowedDistance);
					} else {
						// If looking from above, restore full zoom capability
						controls.maxDistance = 30;
					}
				}

				// --- INERTIA LOGIC ---
				if (keyState.ArrowLeft)  angularVelocity -= ROTATION_ACCEL;
				if (keyState.ArrowRight) angularVelocity += ROTATION_ACCEL;
				
				if (angularVelocity > MAX_VELOCITY) angularVelocity = MAX_VELOCITY;
				if (angularVelocity < -MAX_VELOCITY) angularVelocity = -MAX_VELOCITY;

				rotateOnAxis(pivotGroup, new THREE.Vector3(0, 1, 0), angularVelocity);
				angularVelocity *= ROTATION_FRICTION;
				
				const diff = targetHeightFactor - heightFactor;
				if (Math.abs(diff) > 0.001) {
					heightFactor += diff * 0.1;
					updateGeometry();
				}

				// --- DYNAMIC RENDER ORDER ---
				const getCenterWorld = (mesh) => {
					const box = new THREE.Box3().setFromObject(mesh);
					const center = new THREE.Vector3();
					box.getCenter(center);
					return center;
				};
				
				const solidDistances = [];
				const isRefining = checkbox.checked;
				
				if (isRefining) {
					if (solids.protein.visible) solidDistances.push({ mesh: solids.protein, dist: camera.position.distanceTo(getCenterWorld(solids.protein)) });
					if (solids.fatTip.visible) solidDistances.push({ mesh: solids.fatTip, dist: camera.position.distanceTo(getCenterWorld(solids.fatTip)) });
					if (solids.fatBase.visible) solidDistances.push({ mesh: solids.fatBase, dist: camera.position.distanceTo(getCenterWorld(solids.fatBase)) });
					if (solids.carbsTip.visible) solidDistances.push({ mesh: solids.carbsTip, dist: camera.position.distanceTo(getCenterWorld(solids.carbsTip)) });
					if (solids.carbsBase.visible) solidDistances.push({ mesh: solids.carbsBase, dist: camera.position.distanceTo(getCenterWorld(solids.carbsBase)) });
				} else {
					if (solids.classicProtein.visible) solidDistances.push({ mesh: solids.classicProtein, dist: camera.position.distanceTo(getCenterWorld(solids.classicProtein)) });
					if (solids.classicFat.visible) solidDistances.push({ mesh: solids.classicFat, dist: camera.position.distanceTo(getCenterWorld(solids.classicFat)) });
					if (solids.classicCarbs.visible) solidDistances.push({ mesh: solids.classicCarbs, dist: camera.position.distanceTo(getCenterWorld(solids.classicCarbs)) });
				}
				
				solidDistances.sort((a, b) => b.dist - a.dist);
				solidDistances.forEach((item, index) => { item.mesh.renderOrder = index; });

				// --- CAMERA-DEPENDENT TILT ---
				const polarAngle = controls.getPolarAngle();
				let tiltAngle = (Math.PI / 2) - polarAngle;
				tiltAngle = Math.max(-Math.PI/2, Math.min(Math.PI/2, tiltAngle));

				const tiltQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -tiltAngle);

				Object.values(labelMeshes).forEach(item => {
					if (item && item.mesh && item.mesh.visible) {
						item.mesh.quaternion.copy(item.baseQuat).multiply(tiltQuat);
					}
				});

				// --- CLIPPING PLANE UPDATE ---
				const normalLocal = new THREE.Vector3(2, -1, -1).normalize();
				const pointLocal = currentLocalPlanePosition.clone();
				const pointWorld = pointLocal.clone().applyMatrix4(pivotGroup.matrixWorld);
				const normalWorld = normalLocal.clone().transformDirection(pivotGroup.matrixWorld).normalize();

				globalPlaneTip.setFromNormalAndCoplanarPoint(normalWorld, pointWorld);
				const normalWorldNeg = normalWorld.clone().negate();
				globalPlaneBase.setFromNormalAndCoplanarPoint(normalWorldNeg, pointWorld);

				controls.update();
				renderer.render(scene, camera);
			}

			function rotateOnAxis(object, axis, angle) {
				const q = new THREE.Quaternion();
				q.setFromAxisAngle(axis, angle);
				object.quaternion.premultiply(q);
			}

			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				updateCameraOffset();
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});

			animate();
		})();
	</script>
</body>
</html>
